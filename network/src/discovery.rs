use self::mdns::MdnsWrapper;
use futures::FutureExt;
use futures_timer::Delay;
use ip_network::IpNetwork;
use log::*;
use libp2p::{
    core::{
        connection::ConnectionId,
        transport::ListenerId,
        ConnectedPoint,
    },
    kad::{
        handler::KademliaHandlerProto,
        store::MemoryStore,
        Kademlia,
        KademliaEvent,
        QueryId,
    },
    mdns::MdnsEvent,
    multiaddr::Protocol,
    swarm::{
        ConnectionHandler,
        DialError,
        IntoConnectionHandler,
        NetworkBehaviour,
        NetworkBehaviourAction,
        PollParameters,
    },
    Multiaddr,
    PeerId,
};
use std::{
    collections::{
        HashSet,
        VecDeque,
    },
    io,
    task::{
        Context,
        Poll,
    },
    time::Duration,
};
mod discovery_config;
mod mdns;
pub use discovery_config::DiscoveryConfig;

const SIXTY_SECONDS: Duration = Duration::from_secs(60);

/// Event generated by the `DiscoveryBehaviour`.
#[derive(Debug)]
pub enum DiscoveryEvent {
    /// Notify the swarm of an UnroutablePeer
    UnroutablePeer(PeerId),

    /// Notify the swarm of a connected peer
    Connected(PeerId, Vec<Multiaddr>),

    /// Notify the swarm of a disconnected peer
    Disconnected(PeerId),
}

/// NetworkBehavior for discovery of nodes
pub struct DiscoveryBehaviour {
    /// List of bootstrap nodes and their addresses
    bootstrap_nodes: Vec<(PeerId, Multiaddr)>,

    /// Track the connected peers
    connected_peers: HashSet<PeerId>,

    /// Events to report to the swarm
    events: VecDeque<DiscoveryEvent>,

    /// For discovery on local network, optionally available
    mdns: MdnsWrapper,

    /// Kademlia with MemoryStore
    pub kademlia: Kademlia<MemoryStore>,

    /// If enabled, the Stream that will fire after the delay expires,
    /// starting new random walk
    next_kad_random_walk: Option<Delay>,

    /// The Duration for the next random walk, after the current one ends
    duration_to_next_kad: Duration,

    /// Maximum amount of allowed peers
    max_peers_connected: usize,

    /// If false, `addresses_of_peer` won't return any private IPv4/IPv6 address,
    /// except for the ones stored in `bootstrap_nodes`.
    allow_private_addresses: bool,
}

impl DiscoveryBehaviour {
    /// Adds a known listen address of a peer participating in the DHT to the routing table.
    pub fn add_address(&mut self, peer_id: &PeerId, address: Multiaddr) {
        self.kademlia.add_address(peer_id, address);
    }
}

impl NetworkBehaviour for DiscoveryBehaviour {
    type ConnectionHandler = KademliaHandlerProto<QueryId>;
    type OutEvent = DiscoveryEvent;

    // Initializes new handler on a new opened connection
    fn new_handler(&mut self) -> Self::ConnectionHandler {
        // in our case we just return KademliaHandlerProto
        self.kademlia.new_handler()
    }

    // receive events from KademliaHandler and pass it down to kademlia
    fn inject_event(
        &mut self,
        peer_id: PeerId,
        connection: ConnectionId,
        event: <<Self::ConnectionHandler as IntoConnectionHandler>::Handler as ConnectionHandler>::OutEvent,
    ) {
        self.kademlia.inject_event(peer_id, connection, event);
    }

    fn inject_address_change(
        &mut self,
        peer_id: &PeerId,
        connection_id: &ConnectionId,
        old: &ConnectedPoint,
        new: &ConnectedPoint,
    ) {
        self.kademlia
            .inject_address_change(peer_id, connection_id, old, new)
    }

    // gets polled by the swarm
    fn poll(
        &mut self,
        cx: &mut Context<'_>,
        params: &mut impl PollParameters,
    ) -> Poll<NetworkBehaviourAction<Self::OutEvent, Self::ConnectionHandler>> {
        if let Some(next_event) = self.events.pop_front() {
            return Poll::Ready(NetworkBehaviourAction::GenerateEvent(next_event))
        }

        // if random walk is enabled poll the stream that will fire when random walk is scheduled
        if let Some(next_kad_random_query) = self.next_kad_random_walk.as_mut() {
            while next_kad_random_query.poll_unpin(cx).is_ready() {
                if self.connected_peers.len() < self.max_peers_connected {
                    let random_peer_id = PeerId::random();
                    self.kademlia.get_closest_peers(random_peer_id);
                }

                *next_kad_random_query = Delay::new(self.duration_to_next_kad);
                // duration to next random walk should either be exponentially bigger than the previous
                // or at max 60 seconds
                self.duration_to_next_kad =
                    std::cmp::min(self.duration_to_next_kad * 2, SIXTY_SECONDS);
            }
        }

        // poll Kademlia behaviour
        while let Poll::Ready(kad_action) = self.kademlia.poll(cx, params) {
            match kad_action {
                NetworkBehaviourAction::GenerateEvent(
                    KademliaEvent::UnroutablePeer { peer },
                ) => {
                    return Poll::Ready(NetworkBehaviourAction::GenerateEvent(
                        DiscoveryEvent::UnroutablePeer(peer),
                    ))
                }

                NetworkBehaviourAction::Dial { handler, opts } => {
                    return Poll::Ready(NetworkBehaviourAction::Dial { handler, opts })
                }
                NetworkBehaviourAction::CloseConnection {
                    peer_id,
                    connection,
                } => {
                    return Poll::Ready(NetworkBehaviourAction::CloseConnection {
                        peer_id,
                        connection,
                    })
                }
                NetworkBehaviourAction::NotifyHandler {
                    peer_id,
                    handler,
                    event,
                } => {
                    return Poll::Ready(NetworkBehaviourAction::NotifyHandler {
                        peer_id,
                        handler,
                        event,
                    })
                }
                NetworkBehaviourAction::ReportObservedAddr { address, score } => {
                    return Poll::Ready(NetworkBehaviourAction::ReportObservedAddr {
                        address,
                        score,
                    })
                }
                _ => {}
            }
        }

        while let Poll::Ready(mdns_event) = self.mdns.poll(cx, params) {
            match mdns_event {
                NetworkBehaviourAction::GenerateEvent(MdnsEvent::Discovered(list)) => {
                    // inform kademlia of newly discovered local peers
                    // only if there aren't enough peers already connected
                    if self.connected_peers.len() < self.max_peers_connected {
                        for (peer_id, multiaddr) in list {
                            self.kademlia.add_address(&peer_id, multiaddr);
                        }
                    }
                }
                NetworkBehaviourAction::ReportObservedAddr { address, score } => {
                    return Poll::Ready(NetworkBehaviourAction::ReportObservedAddr {
                        address,
                        score,
                    })
                }
                NetworkBehaviourAction::CloseConnection {
                    peer_id,
                    connection,
                } => {
                    return Poll::Ready(NetworkBehaviourAction::CloseConnection {
                        peer_id,
                        connection,
                    })
                }
                _ => {}
            }
        }

        if let Some(next_event) = self.events.pop_front() {
            return Poll::Ready(NetworkBehaviourAction::GenerateEvent(next_event))
        }

        Poll::Pending
    }

    /// return list of known addresses for a given peer
    fn addresses_of_peer(&mut self, peer_id: &PeerId) -> Vec<Multiaddr> {
        let mut list = self
            .bootstrap_nodes
            .iter()
            .filter_map(|(current_peer_id, multiaddr)| {
                if current_peer_id == peer_id {
                    Some(multiaddr.clone())
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();

        {
            let mut list_to_filter = Vec::new();

            list_to_filter.extend(self.kademlia.addresses_of_peer(peer_id));
            list_to_filter.extend(self.mdns.addresses_of_peer(peer_id));

            // filter private addresses
            // nodes could potentially report addresses in the private network
            // which are not actually part of the network
            if !self.allow_private_addresses {
                list_to_filter.retain(|addr| match addr.iter().next() {
                    Some(Protocol::Ip4(addr)) if !IpNetwork::from(addr).is_global() => {
                        false
                    }
                    Some(Protocol::Ip6(addr)) if !IpNetwork::from(addr).is_global() => {
                        false
                    }
                    _ => true,
                });
            }

            list.extend(list_to_filter);
        }

        info!("Addresses of {:?}: {:?}", peer_id, list);

        list
    }

    fn inject_connection_established(
        &mut self,
        peer_id: &PeerId,
        connection_id: &ConnectionId,
        endpoint: &ConnectedPoint,
        failed_addresses: Option<&Vec<Multiaddr>>,
        other_established: usize,
    ) {
        if other_established == 0 {
            self.connected_peers.insert(*peer_id);
            let addresses = self.addresses_of_peer(peer_id);

            self.events
                .push_back(DiscoveryEvent::Connected(*peer_id, addresses));

            trace!("Connected to a peer {:?}", peer_id);
        }

        self.kademlia.inject_connection_established(
            peer_id,
            connection_id,
            endpoint,
            failed_addresses,
            other_established,
        );
    }

    fn inject_connection_closed(
        &mut self,
        peer_id: &PeerId,
        connection_id: &ConnectionId,
        connection_point: &ConnectedPoint,
        handler: <Self::ConnectionHandler as IntoConnectionHandler>::Handler,
        remaining_established: usize,
    ) {
        if remaining_established == 0 {
            self.connected_peers.remove(peer_id);
            self.events
                .push_back(DiscoveryEvent::Disconnected(*peer_id));

            trace!("Disconnected from {:?}", peer_id);
        }

        self.kademlia.inject_connection_closed(
            peer_id,
            connection_id,
            connection_point,
            handler,
            remaining_established,
        );
    }

    fn inject_new_external_addr(&mut self, addr: &Multiaddr) {
        self.kademlia.inject_new_external_addr(addr)
    }

    fn inject_expired_listen_addr(&mut self, id: ListenerId, addr: &Multiaddr) {
        self.kademlia.inject_expired_listen_addr(id, addr);
    }

    fn inject_dial_failure(
        &mut self,
        peer_id: Option<PeerId>,
        handler: Self::ConnectionHandler,
        err: &DialError,
    ) {
        self.kademlia.inject_dial_failure(peer_id, handler, err)
    }

    fn inject_new_listen_addr(&mut self, id: ListenerId, addr: &Multiaddr) {
        self.kademlia.inject_new_listen_addr(id, addr)
    }

    fn inject_listener_error(
        &mut self,
        id: ListenerId,
        err: &(dyn std::error::Error + 'static),
    ) {
        self.kademlia.inject_listener_error(id, err)
    }

    fn inject_listener_closed(&mut self, id: ListenerId, reason: Result<(), &io::Error>) {
        self.kademlia.inject_listener_closed(id, reason)
    }
}
